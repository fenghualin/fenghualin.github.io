[{"title":"Java虚拟机理解总结","date":"2018-04-28T00:24:58.000Z","path":"2018/04/28/Java虚拟机理解总结/","text":"&emsp;&emsp;Java虚拟机（Java Virtual Machine 简称JVM）是运行所有Java程序的虚拟计算机，Java虚拟机屏蔽了与具体操作系统的相关性，使得Java程序只需生成在Java虚拟机上运行的字节码，就可以在多种平台上运行。正是Java虚拟机使得Java程序能够做到“编译一次，到处运行”，成就了Java。作为Java程序员，必须对Java虚拟机有学习理解，才能做好Java程序开发。当然这里的学习理解只是基本的虚拟机规范的理解，具体细节的理解掌握就太难了，对于Java开发来说也是没有必要的。我认为的Java程序员必须了解的Java虚拟机知识总结如下： 一、Java虚拟机内存管理模型&emsp;&emsp;我们平时使用的虚拟机基本都是HotSpot VM，我就以这个虚拟机为标准来。平时开发和维护系统的时候会经常遇到java.lang.OutOfMemoryError的错误。产生这个问题的原因就是虚拟机内存不够了。内存不够了只是直接原因，真正的原因需要我们理解虚拟机的内存模型、垃圾回收机制，结合我们程序来分析找到具体原因。&emsp;&emsp;Java虚拟机管理的内存包括几个运行时数据内存：方法区、堆、虚拟机栈、本地方法栈、程序计数器，其中方法区和堆是由线程共享的数据区，其他几个是线程隔离的数据区。 Java堆(Heap)&emsp;&emsp;堆是Java虚拟机所管理的内存中最大的一块，Java堆是被所有线程共享的内存区域。在Java虚拟机规范中有描述：所有的对象实例和数组都要在堆上分配。所以Java堆是垃圾书收集器管理的主要区域,可以通过-Xmx和-Xms控制堆的大小。Java堆还细分为：新生代和老年代。分代划分的目的是为了更高效的回收内存。新建的对象都由新生代分配内存。常常又被划分为Eden区和Survivor区。Eden空间不足时会把存活的对象转移到Survivor。新生代的大小可由-Xmn控制，也可用-XX:SurvivorRatio控制Eden和Survivor的比例。经过多次垃圾回收仍然存活的对象就转入老年代。 方法区(Method Area)&emsp;&emsp;方法区也是线程共享的内存区域，存储被虚拟机加载的类信息、常量、静态变量、即时编译的代码数据等。HotSpot虚拟机GC分代收集扩展到方法区，把方法区称为“永久代”。该区域主要是针对常量池和类型的卸载回收。由于永久代内存经常不够用或发生内存泄露，爆出异常java.lang.OutOfMemoryError: PermGen。Jdk8废弃永久代，引入了元空间（Metaspace）。元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存，理论上可以扩展到32位/64位系统可虚拟的内存大小。 虚拟机栈(VM Stack)&emsp;&emsp;虚拟机栈是线程私有的，生命周期与线程是一致，每个方法在执行的时候都会创建一个栈帧，用于存储局部变量表，操作数栈，动态链接，方法出入口等信息，每个方法的调用到执行完成的过程就是一个栈帧入栈到出栈的过程。虚拟机栈规定了2种异常情况，一种是线程请求栈的深度大于虚拟机栈所允许的深度，这时候将会抛出StackOverflowError异常（一般的函数调用都不会大于默认的栈深度，除非递归函数非常深）；另一种是如果当Java虚拟机允许动态扩展虚拟机栈的时候，当扩展的时候没办法分配到内存的时候就会报OutOfMemoryError异常。 本地方法栈(Native Method Stack)&emsp;&emsp;与虚拟机栈执行的基本相同，唯一的区别就是虚拟机栈是执行Java方法的，本地方法栈是执行native方法的；本地方法栈也会抛出StackOverflowError和OutOfMemoryError异常。 程序计数器(Program Counter Register)&emsp;&emsp;程序计数器是一块较小的内存空间，用来指定当前线程执行字节码的行数，每个线程计数器都是私有的，因为每个线程都需要记录执行的行数。该内存区域是Java虚拟机唯一没有规定任何OutOfMemoryError的区域。所以程序计数器对程序员开发来说基本是透明不用管的。 二、内存分配策略 对象优先在Eden分配&emsp;&emsp;新对象在新生代Eden区中分配，当Eden没有足够空间分配时，虚拟机将发起一次Minor GC(从年轻代空间（包括 Eden 和 Survivor 区域）回收内存被称为 Minor GC)，GC后将已有对象放入Survivor中，若Survivor空间不足，则通过分配担保机制提前转移到老年代。 大对象直接进入老年代&emsp;&emsp;大对象是指需要大量连续内存空间的Java对象，例如较长的字符串和较长的数组。经常出现大对象容易导致内存还有不少空间就提前触发垃圾收集来获得连续的大空间来分配给大对象，为了避免这种问题，虚拟机提供了一个-XX：PretenureSizeThreshold参数（只有Serial和ParNew收集器有效），令大于这个参数的值的对象直接在老年代分配。 长期存活的对象进入老年代&emsp;&emsp;虚拟机用分代收集的思想来管理内存，那么新生代是怎么进入老年代的呢。虚拟机给每个对象定义一个对象年龄计数器。如果对象在Eden出生并经过第一次MinorGC然后仍然存活，并且能被Survivor容纳的话，将被移到Survivor中，并且对象年龄设为1。对象在Survivor中没过一次Minor GC，年龄就增加一岁。当年龄增加到一定程度（默认为15岁），就会晋升到老年代。对象晋升老年代的年龄阈值，可以通过参数：-XX:MaxTenuringThreshold设置。 动态对象年龄判定&emsp;&emsp;如果Survivor中的对象年龄都不超过晋升老年代的年龄阈值并且消耗完了Survivor的空间就出问题了，所以虚拟机并不是永远的要求对象必须达到MaxTenuringThreshold才能晋升老年代，如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无需达到MaxTenuringThreshold的要求。 空间分配担保&emsp;&emsp;在发生Minor GC之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象的总空间，如果这个条件成立，那么Minor GC可以确保是安全的(极端情况下内存回收后新生代中所有对象都存活，把Survivor无法容纳的对象直接放入老年代，老年代就必须有能容纳这些对象的空间)。若不成立，则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败，若允许，那么会继续检查老年代最大可用连续空间是否大于历次晋升到老年代对象的平均大小(相当于一个经验值，不保证可以成功)，如果大于，尽管这次Minor GC冒险，也会尝试进行一次Minor GC；如果小于，或者HandlePromotionFailure设置为不允许冒险，那么需要进行一次Full GC。三、垃圾收集器&emsp;&emsp;Jdk7以后，HotSpot虚拟机有7种垃圾收集器：Serial、ParNew、Parallel Scavenge、Serial Old、Parallel Old、CMS、G1。他们之间的关系如下图（连线表示可以组合使用）。新生代收集器：Serial、ParNew、Parallel Scavenge，基本是采用复制算法，因为新生代对象大多是朝生夕灭，存活的少，复制内存小，使用复制简单高效。老年代收集器：Serial Old、Parallel Old、CMS， 基本是采用标记-清除或标记-整理算法，因为老年代对象存活率高，不适合复制算法。整堆收集器：G1，从整体看，是基于标记-整理算法；从局部（两个Region间）看，是基于复制算法。并行（Parallel）指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态，如ParNew、Parallel Scavenge、Parallel Old；并发（Concurrent）指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），如CMS、G1；Minor GC又称新生代GC，指发生在新生代的垃圾收集动作，因为Java对象大多是朝生夕灭，所以Minor GC非常频繁，回收速度也比较快；Major GC又称老年代GC，指发生在老年代的GC；Full GC是指Major GC和Minor GC一起发生同时执行，执行Major GC的时候都会伴随执行Minor GC。 Serial收集器&emsp;&emsp;Serial垃圾收集器是最基本、最早的回收新生代内存的单线程串行收集器；进行垃圾收集时，必须暂停所有工作线程。对于单个CPU的环境，Serial收集器没有线程切换开销，可以获得最高的单线程收集效率。只是说Serial收集器在回收的时候会暂停其他线程，所以就在Client模式下用户的桌面应用场景中适合，管理内存不大，回收时间短，停顿是可以接受的。-XX:+UseSerialGC：添加该参数来显式的使用Serial收集器。 ParNew收集器&emsp;&emsp;ParNew垃圾收集器是Serial收集器的多线程版本，除了多线程外，其余的行为、特点和Serial收集器一样。在Server模式下，ParNew收集器是一个非常重要的收集器，因为除Serial外，目前只有它能与CMS收集器配合工作。&emsp;&emsp;-XX:+UseConcMarkSweepGC：指定使用CMS后，会默认使用ParNew作为新生代收集器。&emsp;&emsp;-XX:+UseParNewGC：强制指定使用ParNew收集器。&emsp;&emsp;-XX:ParallelGCThreads：指定垃圾收集的线程数，ParNew默认的收集线程与CPU数量相同。 Parallel Scavenge收集器&emsp;&emsp;Parallel Scavenge收集器和ParNew垃圾收集器相似，只是Parallel Scavenge注重吞吐量，也称为吞吐量收集器（Throughput Collector）。他的目标是达到一个可控制的吞吐量，吞吐量=运行用户代码时间/(运行用户代码时间+垃圾收集时间)。高吞吐量为目标，即减少垃圾收集时间，让用户代码获得更长的运行时间。Parallel Scavenge收集器提供两个参数用于精确控制吞吐量，分别是控制最大垃圾收集停顿时间的-XX:MaxGCPauseMillis参数和设置吞吐量大小的-XX:GCTimeRatio。此外，还有一个值得关注的参数-XX:+UseAdptiveSizePolicy，开启这个参数后，就不用手工指定新生代的大小（-Xmn）、Eden与Survivor区的比例（-XX:SurvivorRation）、晋升老年代的对象年龄（-XX:PretenureSizeThreshold）等。JVM会根据当前系统运行情况收集性能监控信息，动态调整这些参数，以提供最合适的停顿时间或最大的吞吐量。&emsp;&emsp;Parallel Scavenge收集器适合在要求高吞吐量，对暂停时间要求不高，不需要太多用户交互的后台计算为主的场景。如：批处理系统、科学计算等。 Serial Old收集器&emsp;&emsp;Serial Old收集器是Serial收集器的老年代版本，单线程串行收集器，主要用于Client模式。在Server模式有两大用途：1、在JDK1.5及之前，与Parallel Scavenge收集器搭配使用（JDK1.6有Parallel Old收集器可搭配）；2、作为CMS收集器的后备预案，在CMS并发收集发生Concurrent Mode Failure时使用（CMS收集器里面再谈）。 Parallel Old收集器&emsp;&emsp;Parallel Old收集器Parallel Scavenge收集器的老年代版本，使用多线程和标记-整理算法。JDK1.6开始使用这个收集器，在注重吞吐量以及CPU资源敏感的场景，Parallel Scavenge加Parallel Old收集器的组合最合适。-XX:+UseParallelOldGC：指定使用Parallel Old收集器。 CMS收集器&emsp;&emsp;并发标记清理（Concurrent Mark Sweep，CMS）收集器以获得最短回收停顿时间为目标的收集器。是HotSpot在JDK1.5推出的第一款真正意义上的并发（Concurrent）收集器。非常适合希望系统停顿时间最短，注重服务的响应速度的互联网网站、B/S系统。&emsp;&emsp;CMS收集器是基于标记-清除算法实现，整过过程包括四个步骤，初始标记、并发标记、重新标记、并发清除。其中，初始标记、重新标记这两个步骤需要暂停工作线程，会有短暂的停顿。初始标记只是标记一下GC Roots能直接关联到的对象，速度很快。重新标记是为了修正并发标记期间因用户程序继续运作而导致标记变动的那一部分对象的标记记录，稍微比初始标记慢一点，但是远比并发标记时间短。并发标记和并发清除过程都可以和用户线程一起工作，所以说，CMS总体来说是低停顿的并发收集器。但是CMS也不是完美的，还有三个明显的缺点：&emsp;&emsp;1、对CPU资源非常敏感&emsp;&emsp;并发收集虽然不会暂停用户线程，但因为占用一部分CPU资源，还是会导致应用程序变慢，总吞吐量降低。MS的默认收集线程数量是=(CPU数量+3)/4；当CPU数量多于4个，收集线程占用的CPU资源多于25%，对用户程序影响可能较大；不足4个时，影响更大，可能无法接受。&emsp;&emsp;2、无法处理浮动垃圾,可能出现Concurrent Mode Failure失败&emsp;&emsp;在并发清除时，用户线程新产生的垃圾，称为浮动垃圾。因此不能像其他收集器在老年代几乎填满再进行收集，需要预留一定的内存空间提供给并发收集时使用。-XX:CMSInitiatingOccupancyFraction：设置CMS预留内存空间，JDK1.5默认值为68%，JDK1.6变为大约92%。如果CMS运行期间预留的内存无法满足需要，就会出现“Concurrent Mode Failure”失败,这是虚拟机启动后备预案：临时启用Serail Old收集器来重新进行老年代垃圾回收，这样就停顿很长时间了。所以不能为了节约内存这个参数值设置太大，引起不必要的性能下降。&emsp;&emsp;3、产生大量内存碎片&emsp;&emsp;由于CMS基于”标记-清除”算法，会产生大量不连续的内存碎片，导致分配大内存对象时，无法找到足够的连续内存，从而提前触发Full GC。为了解决这个问题，CMS收集器提供了一个-XX:+UseCMSCompactAtFullCollection开关参数（默认开启），用于在CMS在进行Full GC 前进行内存压缩。但是内存压缩非常耗时，如果每次Full GC都压缩停顿时间就大了，所以引入了另外一个参数-XX:+CMSFullGCsBeforeCompaction设置执行多少次不压缩的Full GC后，来一次压缩整理。默认值是0（表示每次Full GC前都压缩）。 G1收集器&emsp;&emsp;G1（Garbage-First）是JDK7-u4才推出的收集器，未来可以替换掉CMS的收集器。目标是多处理器机器、大内存机器。它符合垃圾收集暂停时间短，同时实现高吞吐量的目标。G1收集器有四个特点：&emsp;&emsp;1、并行与并发：G1能充分利用多CPU、多核环境下的硬件优势，使用多个CPU来缩短Stop the World停顿时间。回收线程和客户线程可以并发执行。&emsp;&emsp;2、分代收集，收集范围包括新生代和老年代：能独立管理整个GC堆（新生代和老年代），而不需要与其他收集器搭配；能够采用不同方式处理不同时期的对象；虽然保留分代概念，但Java堆的内存布局有很大差别；将整个堆划分为多个大小相等的独立区域（Region）； 新生代和老年代不再是物理隔离，它们都是一部分Region（不需要连续）的集合。&emsp;&emsp;3、空间整合：结合多种垃圾收集算法，空间整合，不产生碎片。从整体看，是基于标记-整理算法；从局部（两个Region间）看，是基于复制算法。&emsp;&emsp;4、可预测的停顿： G1除了追求低停顿处，还能建立可预测的停顿时间模型；可以明确指定M毫秒时间片内，垃圾收集消耗的时间不超过N毫秒。&emsp;&emsp;G1收集器最主要的应用是为需要低GC延迟，并具有大堆的应用适合，如：在堆大小约6GB或更大时，可预测的暂停时间可以低于0.5秒；如果现在采用的收集器没有出现问题，不用急着去选择G1；如果应用程序追求低停顿，可以尝试选择G1；是否代替CMS需要实际场景测试后才决定。四、虚拟机监控&emsp;&emsp;刚上线的系统一般都会去监控一下虚拟机的运行情况，以便调优。当系统出现内存溢出或者崩溃的时候为了定位问题我们也需要监控来发现问题，Jdk为我们提供了监控工具，在${JAVA_HOME}/bin目录下面有6个命令行工具以及两个可视化工具。一般我们在服务器上使用命令行工具来监控比较方便，在本地机器使用图形化界面远程监控方便。五、类加载器&emsp;&emsp;类加载器是什么有什么作用，我觉得对程序员来说还是比较重要，因为你要实现一个框架、一个Web服务器、热拔插功能等，都可能需要自己实现类加载器来加载类。一般来说，Java 应用的开发人员不需要直接同类加载器进行交互。Java 虚拟机默认的行为就已经足够满足大多数情况的需求了。不过如果遇到了需要与类加载器进行交互的情况，而对类加载器的机制又不是很了解的话，就很容易花大量的时间去调试 ClassNotFoundException和 NoClassDefFoundError等异常。&emsp;&emsp;顾名思义，类加载器（class loader）用来加载 Java 类到 Java 虚拟机中。一般来说，Java 虚拟机使用 Java 类的方式如下：Java 源程序（.java 文件）在经过 Java 编译器编译之后就被转换成 Java 字节代码（.class 文件）。类加载器负责读取 Java 字节代码，并转换成 java.lang.Class类的一个实例。每个这样的实例用来表示一个 Java 类。通过此实例的 newInstance()方法就可以创建出该类的一个对象。","tags":[{"name":"技术","slug":"技术","permalink":"https://fenghualin.github.io/tags/技术/"},{"name":"java","slug":"java","permalink":"https://fenghualin.github.io/tags/java/"},{"name":"虚拟机","slug":"虚拟机","permalink":"https://fenghualin.github.io/tags/虚拟机/"}]},{"title":"关于敏捷开发的理解","date":"2018-04-16T02:22:56.000Z","path":"2018/04/16/关于敏捷的思考/","text":"什么是敏捷开发&emsp;&emsp;敏捷开发这个概念我想很多人不是很清楚。最常见的错误是拿敏捷开发和瀑布式开发对比，认为敏捷开发是对瀑布式开发的升级优化。其实瀑布模式开发是从软件工程中的软件开发周期模型分类来说的，除了瀑布模型还有迭代模型、螺旋模型等。敏捷开发是多种软件开发项目管理方法的合集的总称、敏捷开发的开发周期模型采用迭代模型。瀑布模式应该是和敏捷开发采用的迭代模型对比，所以不是说软件开发不是用瀑布模型就是敏捷了，要做到敏捷还有很多工作要做。那我们现在再看看敏捷开发比较官方的的定义就不容易理解错误了。&emsp;&emsp;敏捷开发模式是一种从1990年代开始逐渐引起广泛关注的一些新型软件开发方法，是一种应对快速变化的需求的一种软件开发能力。它们的具体名称、理念、过程、术语都不尽相同，相对于”非敏捷”，更强调程序员团队与业务专家之间的紧密协作、面对面的沟通（认为比书面的文档更有效）、频繁交付新的软件版本、紧凑而自我组织型的团队、能够很好地适应需求变化的代码编写和团队组织方法，也更注重做为软件开发中人的作用。&emsp;&emsp;看看上面的定义，是不是还是很懵逼，从这个定义我们很难判断我们是不是敏捷开发。幸好有一个敏捷宣言能很好的帮助我们判断是不是敏捷。敏捷宣言，也叫做敏捷软件开发宣言，正式宣布了四个核心价值和十二条原则，可以指导迭代的以人为中心的软件开发方法。先来看看四个核心价值： 个体和互动高于流程和工具&emsp;&emsp;一般软件开发项目都有自己的流程规范和项目管理软件等工具，流程规范规定了项目组中人员的角色、流程环节，需求人员就做需求分析，开发人员就做开发，测试人员就做测试。各个流程环节就只是对应环节的角色人员参与。并且用项目管理软件来统一管理。这种比较传统和常用的软件项目管理方式的最大弊端就是各个环节的人员个体不能很好的互动，只能参与自己的环节。敏捷倡导的是全员参与，比如需求分析不只是需求分析人员才参与，全员参与需求分析有助于及时发现团队成员对同一个需求理解不一致的问题，这很大程度上避免了缺陷的引入。另外，也有助于规避人力风险。比如，一个需求的开发者突然需要请假，其他开发者可以马上顶替他，因为其他人也参与了其负责开发的需求的分析。此外，全员参与需求分析也有助于全体成员的能力的提升。 工作的软件高于详尽的文档&emsp;&emsp;通常软件开发都需要做好需求文档、概要设计文档、详细设计文档后再编码，如果项目比较大做好这些文档是需要较长时间的，需求变化可能性也很大，那么当软件开发好了，给客户看的时候很可能出现做出来的和客户想要的有很大偏差，或者客户的需求又有很多变化。那再回头修改代价就很大了。工作的软件可以是一个迭代开发出来的一个可以运行演示的版本，也可以是一个迭代开发完成开上线的版本，这个根据具体项目来定。工作的软件能够让团队在每个迭代完成后及时从客户那得到反馈，对变化做出快速的响应，避免了劳动成果的浪费以及方向的偏离，也能最大化让客户的期望得到满足。要做到这一点，我们必须采用迭代周期的方式开发，每一个迭代不能太长，一般不能超过4周。当然必要的文档还是需要的。 客户合作高于合同谈判&emsp;&emsp;很多软件公司给甲方做项目的时候，通常是开发系统前，先要签订好合同，规定好了工期、合同金额、延期等处罚措施。这样的规定只能说是为了保证按时完工，不能保证质量和效果。这样的合同方式也很难实施敏捷开发。对于这种甲方乙方的软件开发项目，要做好敏捷开发，必须要客户合作，客户认同敏捷开发，客户能参与到敏捷项目来。同时合同的方式也需要调整，最好合同金额，期限这些不能规定死，最好能动态的根据需求量和工作量来科学定价。 响应变化高于遵循计划&emsp;&emsp;对应瀑布式的开发模式一般都是做好了需求分析、详细设计后再编码，一般后面的需求变更项目组是不乐意接受的。以至于很多甲方乙方的项目，在项目过程中是要求甲方对需求确认签字的，签字后你要修改需求就不是那么容易了。敏捷是欢迎变化的，通过迭代快速得的用户的反馈，及时响应变化。再看看12条原则，可以很好的指导我们敏捷的方向. 我们最重要的目标，是通过持续不断地及早交付有价值的软件使客户满意。 欣然面对需求变化，即使在开发后期也一样。善于掌控变化，帮助客户获得竞争优势。 经常地交付可工作的软件，相隔几星期或一两个月，倾向于采取较短的周期。 业务人员和开发人员必须相互合作，项目中的每一天都不例外。 激发个体的斗志，以他们为核心搭建项目。提供他们所需的环境和支持，相信他们能够达成目标。 不论团队内外，传递信息效果最好效率也最高的方式是面对面的交谈。 可工作的软件是进度的首要度量标准。 敏捷过程倡导可持续开发。责任人、开发人员和用户要能够共同维持其步调稳定延续。 对技术精益求精，对设计不断完善，将提高敏捷能力。 以简洁为本，极力减少不必要工作量。 最好的架构、需求和设计出自于自组织的团队。 团队定期地反思如何能提高成效，并依此调整团队的行为。敏捷开发适合什么项目&emsp;&emsp;我认为任何项目都能用敏捷开发，无论是甲方乙方的合同项目、公司自己的产品研发、全新系统开发、旧系统的维护都是可以的。这些项目理论上用敏捷都是可以的，除非是甲方乙方这样的项目甲方不认可敏捷的方式、合同上、客户合作上不能达成一致。怎样做好敏捷开发 前期准备&emsp;&emsp;万事开头难，敏捷开发也需要一个前期准备工作，在敏捷中这个前期准备工作也叫迭代0。迭代0完成的任务是组建团队和准备团队工作环境。主要包括如下事项： 项目组成立、相关人员就位，进行必要的敏捷培训。 确定敏捷模型，现在一般都采用Scrum模型，产品主管（PO）和Scrum Master需确定出来，他们需要对敏捷开发熟悉甚至精通。 软件项目内容已经明确，如果是全新开发项目，需要完成初步的系统架构和技术选型工作。 团队协作工具准备好，比如Redmine，Jira等。 开发环境准备好，如开发IDE、版本控制软件、持续集成工具等。 需求怎么做&emsp;&emsp;要做好敏捷开发的需求其实并不容易，特别是全新大项目应该比传统的需求分析难做。敏捷开发的需求是需要规划的，一个大项目你要拆分成很多小需求，各个小需求需要分优先级，然后分配好迭代的顺序，这些都是需要深入的理解需求后才能做好规划的。具体怎么去做需求收集好需求，我觉得和传统的需求收集都差不多，同样也需要写好文档，至少你得写好产品需求文档。不然怎么和团队沟通。&emsp;&emsp;敏捷需求分析的重要的一点特别是要求全员都能参加到需求分析中来，需要组织好需求分析和确认。产品主管（PO）和Scrum Master是需求的负责人，他们来主笔写产品需求文档，一定不要大家都来写，其他人做好需求的理解和评审就行了。&emsp;&emsp;评审确定好的需求就要放到Product backlog里面了，敏捷开发是欢迎需求变化的，所以Product backlog里面的需求项在后续的迭代过程中是可以新增、修改、删除的。 设计怎么做&emsp;&emsp;一般软件项目都有架构设计、概要设计、详细设计。瀑布模型周期的开发模式要求这三种设计都要输出完整的文档。那么敏捷还需要做好这三种设计吗？任何模式的软件开发肯定都是要设计的，就像写文章，下笔前肯定需要构思的。在敏捷开发模式下，架构设计和概要设计需要在迭代0的时候做好。也是需要产出文档的。那么详细设计就不需要在开发前就做好，也可以不用详细设计文档了。敏捷倡导代码就是设计，所以详细设计就在每个迭代的编码过程中。 编码怎么做&emsp;&emsp;敏捷对编码要求很高，敏捷倡导编码就是设计，因为没有详细设计文档指导编码，编码人员必须深刻理解需求和具有良好的设计能力。一般会采用结对编程等方式来保证代码质量和设计。敏捷的设计一般满足当前需要即可不会为后续变化做过度设计，所以很可能在下一个迭代需求变化，需要重构代码，重构的技巧不可或缺。敏捷项目编码质量控制通常做法：统一编码格式规范、静态代码分析、结对编程、代码评审code review、测试驱动开发TDD、适时重构。 测试怎么做&emsp;&emsp;很多软件开发项目中测试都是在系统功能开发完成准备提交测试的时候，测试人员才拿到需求。测试处于需求信息的下游，很容易出现测试不是特别了解需求，不能很好的做好测试用例的设计。严重影响测试质量和效率。在敏捷开发迭代周期很短的情况下，测试更加不能处于需求信息的下游。测试人员必须是从项目立项开始全程参与。&emsp;&emsp;敏捷项目人员配备不多，专职测试人员配置一般1-2人。测试人员必须具有较高的需求分析、测试用例设计、编码能力。能和团队结合一起保证项目的质量。&emsp;&emsp;敏捷是建立快速高效的团队，测试是软件质量的保证。在快速迭代的过程中，每一个迭代都会修改代码对前面的修改产生影响，如果没有自动化测试验证。那么手工测试是无法完成这些验证的。所以开发人员必须做好单元测试代码编写，专职测试人员必须做好自动化测试程序的编写和维护。总结&emsp;&emsp;敏捷开发的概念是一种指导思想，我们理解到了。要在工作中实施，说难也不难。主要看现在的公司组织结构，业务特点和当前的开发模式。如果是专业软件公司给政府和银行做的外包项目，受甲方的制约太多，要敏捷确实不容易。其实很多现有软件项目开发维护是很适合敏捷的模式的，并且可能你现在做的就和敏捷差不多，稍微优化调整下就能满足敏捷的定义了。","tags":[{"name":"技术","slug":"技术","permalink":"https://fenghualin.github.io/tags/技术/"},{"name":"项目管理","slug":"项目管理","permalink":"https://fenghualin.github.io/tags/项目管理/"},{"name":"敏捷","slug":"敏捷","permalink":"https://fenghualin.github.io/tags/敏捷/"}]},{"title":"多线程总结","date":"2018-04-09T00:44:52.000Z","path":"2018/04/09/多线程总结/","text":"多线程的由来&emsp;&emsp;世界上第一台通用计算机“ENIAC”于1946年在美国宾夕法尼亚大学诞生，还未出现操作系统，计算机工作采用手工操作方式。程序员将对应于程序和数据的已穿孔的纸带装入输入机，然后启动输入机把程序和数据输入计算机内存，接着通过控制台开关启动程序针对数据运行；计算完毕，打印机输出计算结果；用户取走结果并卸下纸带后，才让下一个用户上机。数据的输入、程序的启动、结果的输出都需要手工控制，并且只能线性作业，手工速度和CPU的高速运算形成了尖锐矛盾，严重浪费了宝贵的计算机资源。&emsp;&emsp;为了解决这个问题，第一代计算机管理控制程序（操作系统）应运而生，这就是批处理操作系统，它在主机与输入机之间增加一个存储设备——磁带，在批处理操作系统的控制下，计算机可自动成批地把输入机上的用户作业读入磁带，依次把磁带上的用户作业读入主机内存并执行并把计算结果向输出机输出。完成了上一批作业后，又从输入机上输入另一批作业，保存在磁带上，并按上述步骤重复处理。随着外围输入输出设备的发展，cpu的速度不断提高，操作系统也不断的发展,后面出现了分时操作系统、实时操作系统、个人计算机操作系统。&emsp;&emsp;计算机的心脏是CPU，它承担了所有计算任务；而操作系统是计算机的管理者，他负责任务的调度、资源的分配和管理；应用程序则是运行于操作系统之上。一个正在操作系统上运行的程序就是一个进程，进程是一个具有独立功能的程序关于某个数据集合的一次运行活动。 在早期的操作系统中并没有线程的概念，随着计算机的发展，对CPU的要求越来越高，进程之间的切换开销较大，已经无法满足越来越复杂的程序的要求了，于是创造出了线程。线程是程序执行中一个单一的顺序控制流程，是程序执行流的最小单元，是处理器调度和分派的基本单位。一个进程可以有一个或多个线程，各个线程之间共享程序的内存空间。一个标准的线程由线程ID、当前指令指针（pc）、寄存器和堆栈组成。而进程由内存空间（代码、数据、进程空间、打开的文件）和一个或多个线程组成。所以线程的切换比进程快很多，操作系统通过线程能高效的分配cpu片段给各个程序。 多线程的问题&emsp;&emsp;多线程技术充分利用了cpu资源，提高了程序的效率。但是，多线程也带来了线程安全、多线程程序复杂、大量线程需要消耗很多系统资源等问题。 线程安全&emsp;&emsp;什么是线程安全问题，当存在两个或者两个以上的线程对象共享同一个资源，共享数据存在被并发修改的可能，那么就会出现线程安全问题。解决线程安全问题可以从以下几个方面思考：&emsp;&emsp;1. 消除共享变量：把全局变量变为局部变量，局部变量存放在栈，线程间不共享，就不存在线程安全问题了。消除共享数据的不足：如果需要一个对象采集各个线程的信息，或者在线程间传递信息，消除了共享变量就不可行了。&emsp;&emsp;2. 使用线程同步机制：给读写操作同时加锁，使得同时只有一个线程可以访问共享数据。是同时给读写加锁，还是只给写加锁，根据具体需求而定。同步机制的缺点是降低了程序的吞吐量。&emsp;&emsp;3. 采用并发数据结构：java jdk提供了并发的数据结构api，如CopyOnWriteArrayList、CopyOnWriteArraySet、ConcurrentLinkedQueue等。&emsp;&emsp;4. 建立副本：使用ThreadLocal为每一个线程建立一个变量的副本，各个线程间独立操作，互不影响。 线程死锁&emsp;&emsp;多线程编程中，通过加锁来解决线程安全问题的同时，也会带来死锁。为了避免死锁，我们首先弄清楚产生死锁的原因。&emsp;&emsp;所谓死锁是指多个线程因竞争资源而造成的一种僵局（互相等待），若无外力作用，这些进程都将无法向前推进。产生死锁必须同时满足以下四个条件，只要其中任一条件不成立，死锁就不会发生。&emsp;&emsp;1. 互斥条件：线程要求对所分配的资源（如打印机）进行排他性控制，即在一段时间内某资源仅为一个线程所占有。此时若有其他线程请求该资源，则请求线程只能等待。&emsp;&emsp;2. 不剥夺条件：线程所获得的资源在未使用完毕之前，不能被其他线程强行夺走，即只能由获得该资源的线程自己来释放（只能是主动释放)。&emsp;&emsp;3. 请求和保持条件：线程已经保持了至少一个资源，但又提出了新的资源请求，而该资源已被其他线程占有，此时请求线程被阻塞，但对自己已获得的资源保持不放。&emsp;&emsp;4. 循环等待条件：存在一种程资源的循环等待链，链中每一个线程已获得的资源同时被链中下一个线程所请求。若干个线程组成了环路，该环路中每一个线程都在等待着相邻的线程占据的资源。&emsp;&emsp;那么我们在编程中做到以下几点可以预防死锁的发生：&emsp;&emsp;1、程序尽量每次只获得一个锁；&emsp;&emsp;2、考虑好加锁顺序，避免加锁顺序交叉形成循环等待；&emsp;&emsp;3、加锁设置等待时间，避免陷入长期等待的僵局。在Java中不能对synchronized同步块设置超时时间。需要创建一个自定义锁，或使用java.util.concurrent包下的Lock工具类。 线程阻塞、异步编程&emsp;&emsp;线程在执行中如果遇到I/O 操作（如磁盘读写或网络通信），通常要耗费较长的时间，这时操作系统会剥夺这个线程的 CPU 控制权，使其暂停执行，同时将资源让给其他的工作线程。当 I/O 操作完毕时，操作系统将这个线程的阻塞状态解除，恢复其对CPU的控制权，令其继续执行。这种 I/O 模式就是通常的阻塞式 I/O（Blocking I/O）。阻塞模式下，一个线程只能处理一项任务，要想提高吞吐量必须通过不断的增加线程。增加线程要不断消耗系统资源，一定会很快耗尽系统资源。比如，BIO 的sockect服务，一个线程处理一个请求，即使使用了线程池技术，并发量也是有限的。&emsp;&emsp;阻塞I/O也叫同步I/O，与之对应的是非阻塞I/O也叫异步I/O。 异步I/O操作时，不会以阻塞的方式等待I/O操作的完成或数据的返回，而只是将 I/O 请求发送给操作系统，继续执行下一条语句。当操作系统完成I/O操作时，以事件的形式通知执行I/O操作的线程，线程会在特定时候处理这个事件。nginx和node.js处理并发都是采用的事件驱动异步非阻塞模式,所以他们在大并发的http请求处理上表现非常牛逼。&emsp;&emsp;异步主要应用于I/O操作，数据库访问，磁盘操作，Socket访问、HTTP/TCP网络通信，对于IO操作并不需要CPU进行计算，这些数据主要通过磁盘进行处理，如果进行同步操作，需要创建更多的线程，大量创建线程和线程上下文的切换会大量消耗计算机资源，针对I/O操作不需要单独的分配一个线程来处理。异步操作无须额外的线程负担，并且使用回调的方式进行处理，在设计良好的情况下，处理函数可以不必使用共享变量，减少了死锁的可能。","tags":[{"name":"技术","slug":"技术","permalink":"https://fenghualin.github.io/tags/技术/"},{"name":"java","slug":"java","permalink":"https://fenghualin.github.io/tags/java/"},{"name":"多线程","slug":"多线程","permalink":"https://fenghualin.github.io/tags/多线程/"}]},{"title":"关于设计模式的理解","date":"2018-03-26T07:23:31.000Z","path":"2018/03/26/关于设计模式的理解/","text":"&emsp;&emsp;我记得在2010年左右设计模式火爆的时候，那时候程序员的简历上面必须写上熟悉设计模式，也是面试官必问的题目。最近发现找工作的，招人的不怎么提设计模式了，都是讲人工智能、微服务、大数据、区块链等。我想2010年左右Java这样的面向对象的语言的普及使用，面向对象的设计方法正好是设计模式的最佳实践。也许到现在面向对象的设计已经普及，不在是新的技能了，随着各个行业的互联网巨头的发展，人工智能、大数据、微服务等就成了现在的IT技术人员学习的方向了，你要是不简历上面写点大数据、分布式的技术（hadoop、zookeeper、hive、spark…）、人工智能（tensorflow、python…)、微服务（dubbo、spring cloud）这些框架的使用，基本很难找到互联网公司工作。&emsp;&emsp;那是不是因为这么多年的发展，已经有了大量的软件人才了，基本的软件开发编程技能都已经精通熟练了呢，所以基础基本不用太关心了，会用新的技术、新的框架你就能做好软件了呢。显然不是这样的，框架不能帮你完成所有的系统设计和开发、具体的业务还是需要分析设计、编码去实现。没有好的基本功，很难设计出好的系统、写出易于维护和扩展的代码。&emsp;&emsp;今天有时间我又回顾了下设计模式方面的东西,把一些感想写下来。 设计模式起源&emsp;&emsp;‘模式’这个概念，最早是在建筑领域出现，建筑在人类历史有几千年的底蕴，人们总结和积累了很多经验教训。哈佛大学的建筑学博士克里斯托弗.亚历山大，是建筑学领域的模式之父。他的团队总结出了253个模式。软件工程却只有几十年的历史，软件领域的大师们也对软件工程总结出了软件的设计模式。1995年， GoF将收集和整理好的23种设计模式写成了《设计模式》一书、标志着设计模式的诞生。 设计模式介绍&emsp;&emsp;设计模式（Design pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。&emsp;&emsp;看看上面这段教科书式的定义，是不是我们看了还是一脸懵逼。即使你把Gof那一本《设计模式》看完，可能你也很难在系统开发中用上设计模式。把23个模式的定义背下来，开发的时候套上去，真可能弄巧成拙，画虎类犬。&emsp;&emsp;那怎样才能正确理解设计模式和运用好他呢，我认为需要搞清楚我们为什么用设计模式，设计模式的目的，设计模式有什么准则。&emsp;&emsp;应对变化、大家普遍认为设计模式是为了软件的复用，利于他人理解。我觉得这个不是设计模式的根本核心，只要你写的代码清晰，就算是面向过程编程也可以做到。 软件开发中最不好应付的是‘变化’，任何事物都是在变化的，软件也是一个生命体，他要成长要变化。所以好的软件编码是能适应成长变化的（可以理解为系统的不断升级、需求的不断变化）。设计模式就是解决怎么优雅的应对这些变化，比如：设计模式里面的创建型模式就是封装对象创建的变化。&emsp;&emsp;设计模式准则、这里的设计模式准则也可以说是面向对象设计的准则，Gof总结的23个设计模式，基本围绕面向对象设计的六个准则实现。理解掌握了六个准则，才能融会贯通各个设计模式，运用自如。 单一职责原则&emsp;&emsp;单一职责原则，简单的说就是一个类只负责一件事情。很多人说这个原则太简单，但是请不要小看这个准则，这个准则本质也是优雅的应对变化，软件开发中我们经常会出现修改一个功能，影响了其他功能。避免出现这一问题的方法便是遵循单一职责原则。这个原则的把握也是需要你的经验积累，不只是类要单一职责，你的类里面的方法、更高层次的模块等都需要遵循。 里氏替换原则&emsp;&emsp;里氏替换原则，第一次看见这个原则真的感觉这个名字怪怪的，看名字是不知道啥意思了，这项原则最早是在1988年，由麻省理工学院的一位姓里的女士（Barbara Liskov）提出来的，我们的软件大师们就取了个这么的名字。那名字定了就也不好改了，就这样叫吧。看看具体的里氏替换原则的定义：任何基类可以出现的地方，子类一定可以出现。&emsp;&emsp;当使用继承时，需要遵循里氏替换原则。继承做为现代面向对象语言三大特性之一，给面向对象编程提供了基础，但是继承使用不好也会带来灾难。父类已经实现好的方法，如果子类对这些非抽象方法任意修改，就会对整个继承体系造成破坏，父类出现的地方，子类出现就有问题了，子类改变了父类的这个行为。也就是说，子类可以扩展父类的功能，但不能改变父类原有的功能。所以我们在使用继承的时候不要覆盖父类的非抽象方法，也最好不要重载父类的方法。&emsp;&emsp;在实际开发过程中，我们常常会直接重写父类的方法来完成新的功能，这样写起来简单，但继承体系的可复用性会变差，运用多态特性时，程序运行得到错误结果的可能性很大。如果非要重写父类的方法，可以用其他方式来做：原来的父类和子类都继承一个基类，原有的继承关系去掉，采用依赖、聚合，组合等关系代替。你看这里处理的是继承体系中的变化，对变化的抽象封装。 依赖倒置原则&emsp;&emsp;依赖倒置原则的定义：高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。&emsp;&emsp;在面向对象程序编程这个层次来看这个原则就是：面向接口编程。面向接口编程，我们程序就是依赖的接口、没有依赖实现。很好的实现了代码解耦。比如我们常用的Spring框架就是实现了依赖倒置。在Spring框架下编码我们就是面向接口编程了。&emsp;&emsp;依赖倒置原则，不只是代码层面的面向接口编程。在更高层次上面也要遵循这个原则，比如单个系统里面的分层，比如MVC框架使用中，我们要分清楚他们的层级关系，那个是上层，各个层级的依赖要能很好的解耦。包括更高层级的系统和系统之间的依赖。这些都是架构的时候需要结合业务特点来分析好依赖关系，做好解耦处理。 接口隔离原则&emsp;&emsp;接口隔离原则的定义：客户端不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上。&emsp;&emsp;前面讲了我们要面向接口编程，那么类之间的依赖、模块之间的依赖、系统之间的依赖都是通过接口来传递依赖关系。上面的接口隔离原则的第一句‘客户端不应该依赖它不需要的接口’,其实就是你暴露给其他模块、其他系统的接口里面只包含他需要的方法。第二句‘一个类对另一个类的依赖应该建立在最小的接口上’，也就是明确说类之间的依赖接口也只包含他需要的方法。其实简单点说，就是不要定义一个很大的接口，里面包括很多的方法。这样的接口就是臃肿的，就像一个类臃肿了，包括了很多功能，责任就不单一了。面对变更修改，会影响很多功能。&emsp;&emsp;是不是觉得接口隔离原则和单一职责原则有点相似呢，不是的。接口隔离主要针对接口定义来说，是对接口约束，接口的设计定义好坏关系到系统间类、模块、系统直接的逻辑内聚和耦合。单一职责强调的是职责，是在不同层级上都可以适用的，所以在接口定义这个层级来说你也是需要考虑单一职责的问题。&emsp;&emsp;接口隔离到底要定义多小的接口，或者多大的接口，这个需要具体业务考虑。不一定是越少越好，越少越好就成了任何接口我就定义一个方法就ok了。永远没有最好的设计，只要能满足当前业务需要和应对后续变化就是很好的了。我们不要犯基础性和常识性的错误，比如为了简单方便，懒得思考设计，定义一个大杂烩接口。 迪米特法则&emsp;&emsp;迪米特法则（Law of Demeter）又叫作最少知道原则（Least Knowledge Principle 简写LKP），就是说一个对象应当对其他对象有尽可能少的了解,不和陌生人说话。&emsp;&emsp;迪米特法则的目的在于降低类之间的耦合，提高类的内聚。比如你定义了一个狗这个类，给这个类定义了一个行走的方法；然后你定义一个人这个类，人去调用狗的行走的方法，指挥狗行走。整个行走的控制都是狗这个类去处理。这个就是符合迪米特法则。但是，如果你行走这个方法不去处理行走功能，而是返回一个狗的腿的对象给人，人来控制狗的腿去行走。那么就违反了迪米特法则。这就是在和陌生人说话了，破坏了高内聚低耦合。 开闭原则&emsp;&emsp;开闭原则的定义：一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。&emsp;&emsp;当软件需要变化时，我们是通过扩展实现变化，而不是通过修改已有的代码来实现变化。如果一个软件系统满足开闭原则，那么这个软件就是可复用性好、稳定、高内聚低耦合的。开闭原则是面向对象设计的终极目标，是前面各种准则和各种设计模式运用要到达的目的。我想不可能完全做到对扩展开发和对修改关闭，我们应该以这个目标，无限接近目标。设计模式怎么用&emsp;&emsp;设计模式怎么用呢，是不是把23个模式全部背下来，使用的时候对号入座呢。我想可能没什么用，但是我们还是需要看看23个模式是什么，毕竟是很多年经验的总结。我们开发系统过程中，遇到的各种业务情况，23个模式一定不能全部覆盖搞定。&emsp;&emsp;其实，面相对象设计的核心目的是为了实现系统代码的高内聚、低耦合、封装变化。以上的六个准则基本都是为了解决这三点问题。重点就是要封装变化，怎么才能抽取变化，做好封装，这个也还是需要深入理解业务需求，才能正确的抽取变化。其实除了上面六点原则，还有一点很重要的是“多用组合，少用继承”，组合比继承能更好的封装变化。","tags":[{"name":"技术，设计模式","slug":"技术，设计模式","permalink":"https://fenghualin.github.io/tags/技术，设计模式/"}]},{"title":"Hello Blog","date":"2018-03-24T09:21:31.000Z","path":"2018/03/24/helloblog/","text":"Hello 博客，我又回来了。分分合合多次了，都怪我没有毅力。这么多年后现在成熟了很多，我要再一次找你回来。这一次在github上给你建立了个人网页，迎接你回来。我也积累了很多的话要和你说，一定要听我给你慢慢道来。相信我一定能坚持下来。 年纪大了，以前很多的事情都没告诉你积累下来，现在都想不起来了，或者以前有记录，但是都记录到其他的乱七八糟的地方，也找不到在什么地方了，连搜索引擎都搜索不到。 从2000年左右你进入中国，都快20年了。虽然现在微博、微信订阅号等很流行。但是blog还是很好的记录文字的地方。并且可以通过微博和微信更广泛的传播。 做了这么多年软件开发，现在我终于发现不断学习新东西和总结过去经验非常重要，用blog来记录学习和经验教训是非常有帮助的。 互联网，软件行业工作流动性很大，说不定哪一天公司挂了，我又要跳槽了，到时候40来岁还要去面试，短暂的面试时间，年轻的面试官可能很难评估出我的能力。那么我把记录在你这里的信息给他看看也许有很大帮助。 我保证，从今以后，我至少两周要给你汇报一次，尽量一周一次。","tags":[{"name":"闲谈","slug":"闲谈","permalink":"https://fenghualin.github.io/tags/闲谈/"}]}]